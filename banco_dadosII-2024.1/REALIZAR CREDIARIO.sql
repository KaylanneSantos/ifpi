----------------------------------------------------FUNÇÃO CREDIÁRIO---------------------------------------------------------------
CREATE OR REPLACE FUNCTION CARNE_CREDIARIO(COD_P INT, QUANT_P INT)
RETURNS VOID AS $$
DECLARE
	COD_C INT; -- CREDIARIO
	TAXA_J NUMERIC(8,2);
	VALOR_J NUMERIC(8,2);
	VALOR_P NUMERIC(8,2);
	VALOR_TT NUMERIC(8,2);
	DATA_V TIMESTAMP := CURRENT_TIMESTAMP;
BEGIN
	SELECT C.COD INTO COD_C FROM CREDIARIO C JOIN PEDIDO P ON P.COD = C.COD_PEDIDO WHERE C.COD_PEDIDO = COD_P;
	SELECT VALOR_TOTAL INTO VALOR_TT FROM PEDIDO WHERE COD = COD_P;

	IF QUANT_P > 0 AND QUANT_P <= 6 THEN
		VALOR_P := (VALOR_TT / QUANT_P);

		FOR PARCELA IN 1..QUANT_P LOOP
			INSERT INTO CREDIARIO(COD_PEDIDO, QUANTIDADE_PARCELA, VALOR_PARCELA,DATA_VENCIMENTO) 
			VALUES(COD_P, PARCELA, VALOR_P, DATA_V);
			DATA_V := DATA_V + INTERVAL '1 MONTH';
		END LOOP;
	
		RAISE INFO 'PARCELAS DO CREDIÁRIO CRIADAS COM SUCESSO.';

	ELSIF QUANT_P > 6 AND QUANT_P <= 12 THEN

		TAXA_J := 0.005;
		VALOR_J := VALOR_TT * TAXA_J;
		VALOR_P := (VALOR_TT + VALOR_J) / QUANT_P;

		FOR PARCELA IN 1..QUANT_P LOOP
			INSERT INTO CREDIARIO(COD_PEDIDO, QUANTIDADE_PARCELA, VALOR_PARCELA,DATA_VENCIMENTO) 
			VALUES(COD_P, PARCELA, VALOR_P, DATA_V);
			DATA_V := DATA_V + INTERVAL '1 MONTH';
		END LOOP;

		RAISE INFO 'PARCELAS DO CREDIÁRIO CRIADAS COM SUCESSO.';
	ELSE
		RAISE EXCEPTION 'QUANTIDADE DE PARCELAS NÃO PERMITIDAS.';
	END IF;
END;
$$ LANGUAGE PLPGSQL;

-----------------------------------------------FINALIZAR CREDIÁRIO--------------------------------------------------------------

CREATE OR REPLACE FUNCTION PAGAR_CARNE(CPF_C VARCHAR(15), DATA_PAG TIMESTAMP DEFAULT CURRENT_TIMESTAMP)
RETURNS TABLE(
    "n°Parcela" INT,
    "Cliente" VARCHAR,
    "CPF" VARCHAR(15),
    "Valor Parcela" NUMERIC(10, 2),
    "Produto" VARCHAR,
    "Quantidade" INT,
    "Valor Unitario" NUMERIC(10, 2),
    "Loja" VARCHAR,
    cnpj VARCHAR(14),
    "Funcionário" VARCHAR,
    "Data Vencimento" VARCHAR(10),
    "Data Pagamento" VARCHAR(10),
    "id°Pedido" INT
) AS $$
DECLARE
	COD_CLI INT; --CLIENTE
	COD_P INT; --PEDIDO
	COD_C INT; --CREDIARIO
	VALOR_P NUMERIC(8,2); --VALOR PARCELA
	DATA_V TIMESTAMP; --DATA VENCIMENTO

	DATA_P TIMESTAMP; --DATA PAGAMENTO
	DIAS_ATRASO INT; --DIAS ATRASO
	
	JUROS_ATRASO NUMERIC(4,2); -- JUROS ATRASO
	JUROS_DIARIO NUMERIC(4,4) := 0.005;
BEGIN
	SELECT C.COD INTO COD_CLI FROM CLIENTE C JOIN PEDIDO P ON P.COD_CLIENTE = C.COD AND CPF ILIKE CPF_C; -- CLIENTE
	SELECT P.COD INTO COD_P FROM PEDIDO P JOIN CREDIARIO C ON C.COD_PEDIDO = P.COD WHERE P.COD_CLIENTE = COD_CLI AND C.COD_PEDIDO = P.COD AND P.PAGO = TRUE AND DATA_PAGAMENTO IS NULL GROUP BY P.COD; --PEDIDO
	SELECT C.COD, VALOR_PARCELA, DATA_VENCIMENTO INTO COD_C, VALOR_P, DATA_V FROM CREDIARIO C JOIN PEDIDO P ON P.COD = C.COD_PEDIDO WHERE P.COD_CLIENTE = COD_CLI AND C.COD_PEDIDO = COD_P AND P.PAGO = TRUE AND DATA_PAGAMENTO IS NULL; --CREDIARIO
	
	SELECT DATA_PAGAMENTO INTO DATA_P FROM CREDIARIO C WHERE QUANTIDADE_PARCELA = (SELECT MIN(QUANTIDADE_PARCELA) FROM CREDIARIO C WHERE C.COD_PEDIDO = COD_P AND DATA_PAGAMENTO IS NULL) AND C.COD_PEDIDO = COD_P; --DATA PAGAMENTO
	SELECT EXTRACT(DAY FROM DATA_PAG - DATA_V) INTO DIAS_ATRASO FROM CREDIARIO; --QUANT DE DIAS DE ATRASO

	IF EXISTS(SELECT * FROM CLIENTE WHERE COD = COD_CLI) THEN
		IF EXISTS(SELECT * FROM PEDIDO P JOIN CREDIARIO C ON C.COD_PEDIDO = P.COD WHERE C.COD_PEDIDO = COD_P AND P.PAGO = TRUE) THEN
			IF DATA_P IS NOT NULL THEN
				RAISE EXCEPTION 'PARCELA JÁ PAGA.';
			ELSE
				IF DIAS_ATRASO > 0 THEN
					JUROS_ATRASO := VALOR_P * JUROS_DIARIO * DIAS_ATRASO;
				ELSE
					JUROS_ATRASO := 0;
				END IF;	
	
				--ATUALIZA A PARCELA COM O VALOR DO JUROS
				UPDATE CREDIARIO SET 
					DATA_PAGAMENTO = DATA_PAG,
					VALOR_PARCELA = VALOR_P + JUROS_ATRASO
				WHERE QUANTIDADE_PARCELA =
					(SELECT MIN(QUANTIDADE_PARCELA) FROM CREDIARIO C JOIN PEDIDO P ON P.COD = C.COD_PEDIDO 
				WHERE C.COD_PEDIDO = COD_P AND DATA_PAGAMENTO IS NULL);

				RAISE INFO 'PARCELA PAGA COM SUCESSO.';
			END IF;
		ELSE
			RAISE EXCEPTION 'O PEDIDO INFORMADO NÃO EXISTE OU AINDA NÃO FOI FINALIZADO.';
		END IF;
	ELSE
		RAISE EXCEPTION 'O CLIENTE NÃO POSSUI PARCELAS A PAGAR.';
	END IF;
	
	RETURN QUERY
	SELECT * FROM VER_CARNE(COD_P);
END;
$$ LANGUAGE PLPGSQL;

-------------------------------------------------------VER CARNÊ CREDIARIO-------------------------------------------------------------------------

CREATE OR REPLACE FUNCTION VER_CARNE(COD_P INT)
RETURNS TABLE(
    "n°Parcela" INT,
    "Cliente" VARCHAR,
    "CPF" VARCHAR(15),
    "Valor Parcela" NUMERIC(10, 2),
    "Produto" VARCHAR,
    "Quantidade" INT,
    "Valor Unitario" NUMERIC(10, 2),
    "Loja" VARCHAR,
    cnpj VARCHAR(14),
    "Funcionário" VARCHAR,
    "Data Vencimento" VARCHAR(10),
    "Data Pagamento" VARCHAR(10),
    "id°Pedido" INT
) AS $$
DECLARE 
    CPF_C VARCHAR(15);
BEGIN
    SELECT CPF INTO CPF_C FROM CLIENTE CLI 
    JOIN PEDIDO P ON CLI.COD = P.COD_CLIENTE
    JOIN CREDIARIO C ON P.COD = C.COD_PEDIDO
    WHERE P.COD = COD_P GROUP BY CLI.CPF;
    
    RETURN QUERY
    SELECT *
    FROM CARNE_CREDIARIO CC
    WHERE CC.CPF = '123.456.789-10';
END;
$$ LANGUAGE PLPGSQL;

----------------------------------------------------------------------------------------------------------------------------


SELECT ADD_PEDIDO('123.456.789-10', 'Vestido Longo de Festa', 5, 'Crediário','345.678.901-23',7)
SELECT * FROM FINALIZAR_PEDIDO('123.456.789-10')
SELECT * FROM PAGAR_CARNE('123.456.789-10', '07-09-2024')
SELECT * FROM VER_CARNE(56)

SELECT * FROM PEDIDO --DELETE FROM PEDIDO
SELECT * FROM ITEM_PEDIDO --DELETE FROM ITEM_PEDIDO
SELECT * FROM CREDIARIO --DELETE FROM CREDIARIO
SELECT * FROM CLIENTE
SELECT * FROM FUNCIONARIO
SELECT * FROM LOJA
SELECT * FROM ESTOQUE
SELECT * FROM PRODUTO